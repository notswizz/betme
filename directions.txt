# BetChat Application Architecture and Flow

## Overview
BetChat is an AI-powered sports betting assistant that allows users to place bets through a chat interface. The application features a modern, gradient-rich UI with smooth animations and mobile-first design.

## Core Components

### 1. Side Menu Layout
The side menu follows a vertical layout with three main sections:
- Top: New Chat button for starting fresh conversations
- Middle: Dynamic content area
  * Token Balance with animated gradient icon and "+" button
  * BetStats cards showing user statistics
- Bottom: BetChat branding section
  * Compact logo and title with minimal spacing
  * Sits directly against content with 1px padding
  * Subtle border separator with 50% opacity

#### Token Balance Component
- Gradient background with blur effect
- Animated token icon with radiating lines
- Compact "+" button with hover animations
- Expandable form for adding tokens
- Real-time balance updates

#### BetStats Component
Modern stat cards with:
- Total Bets (156): Purple gradient icon
- Pending (23): Amber gradient with rotating line animation
- Won (89): Green gradient with checkmark
- Accuracy (92%): Blue gradient with graph icon
- Rank (#7): Pink gradient with star icon
- Each stat has hover animations and pulse effects

### 2. Mobile Interface
- Sticky header with centered BetChat logo
- Slide-out menu with backdrop blur
- Top-right logout button with red accent
- Animated hamburger menu
- Full-height layout optimization
- Bottom-anchored chat input

### 3. Chat Interface
- Gradient message bubbles
- Snap scrolling for smooth navigation
- Quick action buttons with hover effects
- Image upload capability
- Smart message grouping

### 4. Betting System
Files involved:
- `utils/betSubmission.js`: Bet submission logic
- `models/Bet.js`: Bet data schema
- `pages/api/bets/create.js`: Bet creation endpoint

Betting flow:
1. User initiates bet (through chat or image)
2. AI analyzes request via venice.js
3. Bet details structured and validated
4. User confirms bet details
5. Bet submitted to database
6. Token balance updated
7. Success confirmation displayed

### 5. Authentication System
Files involved:
- `utils/auth.js`: Authentication utilities
- `components/auth/LoginForm.js`: Login interface
- `pages/api/auth/login.js`: Authentication endpoint

Auth flow:
1. User logs in with email/password
2. Server validates credentials
3. JWT token issued and stored
4. Token included in all API requests
5. Logout clears token and resets state

### 6. Stats and Reputation System
Files involved:
- `components/wallet/BetStats.js`: Stats display component
- `pages/api/bets/stats.js`: Stats calculation endpoint

Features:
- Betting statistics (total, pending, won)
- Judging reputation
  * Total bets judged
  * Accuracy rate
  * Global rank
- Real-time updates

## Message Processing Pipeline
Primary files:
- `pages/api/chat/process.js`: Central message processing hub
- `utils/convoAnalyze.js`: Message analysis and action handling
- `utils/venice.js`: AI integration for message understanding
- `utils/tesseract.js`: OCR for bet slip processing

Message flow:
1. User sends message through ChatContainer.js
2. Message is sent to /api/chat/process endpoint with JWT token
3. Process.js:
   - Verifies authentication
   - Checks token balance
   - Manages conversation history
   - Routes message to appropriate handler

### Message Types and Handling

#### Regular Messages
Flow:
1. Message received by process.js
2. Sent to analyzeConversation in convoAnalyze.js
3. Intent is analyzed, returns one of:
   - direct: Immediate responses (balance, listings)
   - action: Needs confirmation (bets, tokens)
   - chat: Normal chat message
4. Response is generated and returned to UI

#### Action Confirmation
Flow:
1. User confirms action in UI
2. Confirmation sent to process.js
3. handleAction in convoAnalyze.js processes it
4. Action is executed (place bet, add tokens, etc.)
5. Confirmation message returned to UI

#### Image Processing
Flow:
1. User uploads bet slip image
2. tesseract.js extracts text
3. Text analyzed by AI through venice.js
4. Structured bet data created
5. Bet slip form displayed for confirmation

## Technical Details

### Database Integration
Models:
- `models/User.js`: User data and token balance
- `models/Bet.js`: Bet records
- `models/Conversation.js`: Chat history
- `utils/mongodb.js`: Database connection

Database operations:
1. Conversation tracking
2. Bet recording
3. Balance management
4. User data storage
5. Stats and reputation tracking

### API Structure
1. Chat Processing:
   ```
   /api/chat/process
   - Handles all message types
   - Routes to appropriate handlers
   - Manages conversation state
   ```

2. Actions:
   ```
   /api/bets/create
   /api/bets/stats
   /api/actions/balance
   /api/actions/listing
   - Handle specific actions
   - Require authentication
   - Return structured responses
   ```

### Error Handling
1. Authentication:
   - Token validation
   - Session management
   - Access control
   - Automatic logout on token expiry

2. Action Processing:
   - Input validation
   - Balance checks
   - Data validation
   - Error messages to UI

3. Message Processing:
   - AI processing errors
   - Invalid actions
   - Rate limiting

### Environment Requirements
Required variables:
- MONGODB_URI: Database connection
- JWT_SECRET: Authentication
- AI_API_KEY: Venice AI integration

## Development Notes

### State Management
1. Server State:
   - MongoDB for persistence
   - Conversation tracking
   - User data and stats

2. Client State:
   - React state for UI
   - localStorage for auth
   - Real-time updates

### Security
1. Authentication:
   - JWT validation
   - Token expiration
   - Secure storage
   - Logout functionality

2. Data Validation:
   - Input sanitization
   - Schema validation
   - Type checking

### Error Recovery
1. Token Issues:
   - Auto refresh
   - Re-authentication
   - Clear invalid tokens

2. Action Failures:
   - Retry logic
   - Error messages
   - State recovery

## Technical Implementation

### 1. Styling System
Using Tailwind CSS with custom utilities:
```css
.animate-gradient-x {
  background-size: 200% 200%;
  animation: gradient-x 3s ease infinite;
}
```

### 2. Component Structure
Modular components with clear separation:
- Layout components (ChatContainer, SideMenu)
- Feature components (TokenBalance, BetStats)
- UI components (buttons, cards, icons)

### 3. State Management
- React hooks for local state
- Context for global state
- Real-time updates via WebSocket

### 4. Mobile Optimization
- Responsive breakpoints
- Touch-friendly interfaces
- Performance optimization

### 5. Animation System
- CSS transitions
- React state-based animations
- Gradient animations
- Hover effects

## Development Guidelines

### 1. Styling Conventions
- Use Tailwind classes
- Follow gradient pattern:
  ```jsx
  className="bg-gradient-to-br from-gray-900/95 to-gray-800/95"
  ```
- Maintain consistent spacing
- Use relative units

### 2. Component Organization
- Keep components focused
- Share common styles
- Maintain consistent structure

### 3. Mobile First
- Design for mobile first
- Add desktop enhancements
- Test on multiple devices

### 4. Performance
- Optimize animations
- Lazy load components
- Minimize re-renders

### 5. Accessibility
- Semantic HTML
- ARIA labels
- Keyboard navigation
- Color contrast

## Error Handling
1. User Feedback:
   - Clear error messages
   - Loading states
   - Success confirmations

2. Recovery:
   - Retry mechanisms
   - Fallback UI
   - State restoration

## Future Improvements
1. Enhanced Animations:
   - More fluid transitions
   - Reduced motion options
   - Performance optimization

2. Better Mobile UX:
   - Gesture controls
   - Haptic feedback
   - Native-like feel

3. Accessibility:
   - Screen reader support
   - Keyboard shortcuts
   - High contrast mode 